# This file has been automatically generated by the wbfbd tool.
# Do not edit it manually, unless you really know what you do.
# https://github.com/Functional-Bus-Description-Language/PyWbFBD

import math

BUS_WIDTH = {{.BusWidth}}

def make_mask(m):
    return ((1 << (m[0] + 1)) - 1) ^ ((1 << m[1]) - 1)

class ConfigSingleSingle:
    def __init__(self, interface, addr, mask):
        self.interface = interface
        self.addr = addr
        self.mask = make_mask(mask)
        self.shift = mask[1]

    def read(self):
        return (self.interface.read(self.addr) & self.mask) >> self.shift

    def write(self, val):
        self.interface.write(self.addr, val << self.shift)

class ConfigSingleContinuous:
    def __init__(self, interface, start_addr, reg_count, start_mask, end_mask, increasing_order):
        self.interface = interface
        self.addrs = range(start_addr, start_addr + reg_count)
        self.masks = []
        self.start_shift = start_mask[1]
        for i in range(reg_count):
            if i == 0:
                self.masks.append(make_mask(start_mask))
            elif i == reg_count - 1:
                self.masks.append(make_mask(end_mask))
            else:
                self.masks.append(make_mask((BUS_WIDTH-1, 0)))
        if increasing_order == False:
            self.addrs.reverse()
            self.masks.reverse()

    def read(self):
        val = 0
        shift = 0
        for i, a in enumerate(self.addrs):
            mask = self.masks[i]
            if i == 0:
                v = (self.interface.read(a) & mask) >> self.start_shift
                val = v
                shift = BUS_WIDTH - self.start_shift
            else:
                v = self.interface.read(a) & mask
                val |= v << shift
                shift += BUS_WIDTH
        return val

    def write(self, val):
        for i, a in enumerate(self.addrs):
            mask = self.masks[i]
            if i == 0:
                self.interface.write(a, (val << self.start_shift) & mask)
                val = val >> BUS_WIDTH - self.start_shift
            else:
                self.interface.write(a, val & mask)
                val = val >> BUS_WIDTH

class MaskSingleSingle:
    def __init__(self, interface, addr, mask):
        self.interface = interface
        self.addr = addr
        self.mask = ((1 << (mask[0] + 1)) - 1) ^ ((1 << mask[1]) - 1)
        self.shift = mask[1]
        self.width = mask[0] - mask[1] + 1

    def read(self):
        return (self.interface.read(self.addr) & self.mask) >> self.shift

    def set(self, bits=None):
        if bits == None:
            bits = range(self.width)
        elif type(bits) == int:
            bits = [bits]

        mask = 0
        for b in bits:
            assert 0 <= b < self.width, "mask overrange"
            mask |= 1 << b

        self.interface.write(self.addr, mask << self.shift)

    def update(self, bits, mode="set"):
        if mode not in ["set", "clear"]:
            raise Exception("invalid mode '" + mode + "'")
        if bits == None:
            raise Exception("bits to update cannot have None value")
        if type(bits).__name__ in ["list", "tuple", "range", "set"] and len(bits) == 0:
            raise Exception("empty " + type(bits) + " of bits to update")

        mask = 0
        reg_mask = 0
        for b in bits:
            assert 0 <= b < self.width, "mask overrange"
            if mode == "set":
                mask |= 1 << b
            reg_mask |= 1 << b

        self.interface.rmw(self.addr, mask << self.shift, reg_mask << self.shift)

class StatusSingleSingle:
    def __init__(self, interface, addr, mask):
        self.interface = interface
        self.addr = addr
        self.mask = ((1 << (mask[0] + 1)) - 1) ^ ((1 << mask[1]) - 1)
        self.shift = mask[1]

    def read(self):
        return (self.interface.read(self.addr) & self.mask) >> self.shift


class StatusArraySingle:
    def __init__(self, interface, addr, mask, item_count):
        self.interface = interface
        self.addr = addr
        self.mask = ((1 << (mask[0] + 1)) - 1) ^ ((1 << mask[1]) - 1)
        self.shift = mask[1]
        self.item_count = item_count

    def read(self, idx=None):
        if idx is None:
            idx = tuple(range(0, self.item_count))
        elif type(idx) == int:
            assert 0 <= idx < self.item_count
            return (self.interface.read(self.addr + idx) & self.mask) >> self.shift
        else:
            for i in idx:
                assert 0 <= i < self.item_count

        return [(self.interface.read(self.addr + i) & self.mask) >> self.shift for i in idx]


class StatusArrayMultiple:
    def __init__(self, interface, addr, start_bit, width, item_count, items_per_access):
        self.interface = interface
        self.addr = addr
        self.start_bit = start_bit
        self.width = width
        self.item_count = item_count
        self.items_per_access = items_per_access
        self.reg_count = math.ceil(item_count / self.items_per_access)

    def read(self, idx=None):
        if idx is None:
            idx = tuple(range(0, self.item_count))
            reg_idx = tuple(range(self.reg_count))
        elif type(idx) == int:
            assert 0 <= idx < self.item_count
            reg_idx = idx // self.items_per_access
            shift = self.start_bit + self.width * (idx % self.items_per_access)
            mask = (1 << self.width) - 1
            return (self.interface.read(self.addr + reg_idx) >> shift) & mask
        else:
            reg_idx = set()
            for i in idx:
                assert 0 <= i < self.item_count
                reg_idx.add(i // self.items_per_access)

        reg_values = {reg_i : self.interface.read(self.addr + reg_i) for reg_i in reg_idx}

        values = []
        for i in idx:
            shift = self.start_bit + self.width * (i % self.items_per_access)
            mask = (1 << self.width) - 1
            values.append((reg_values[i // self.items_per_access] >> shift) & mask)

        return values

{{.Code}}
